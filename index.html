<!DOCTYPE html>
<html>
<head>
    <title>Shared Memory Throughput Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 40px;
            background-color: #f0f0f0;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stats {
            margin-top: 20px;
            font-size: 16px;
            line-height: 1.6;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            border: none;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        input {
            padding: 8px;
            font-size: 16px;
            margin: 5px;
            width: 100px;
        }
        .controls {
            margin-bottom: 20px;
        }
        .message-log {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .message {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <input type="number" id="messageSize" value="1024" min="1" max="1048576"> bytes per message
            <input type="number" id="duration" value="5" min="1" max="60"> seconds test
            <button onclick="startTest()">Start Test</button>
            <button onclick="stopTest()">Stop Test</button>
        </div>
        <div class="stats" id="stats">
            Click Start Test to begin throughput measurement
        </div>
        <div class="controls">
            <input type="number" id="interval" value="1000" min="100" max="10000"> ms interval
            <button onclick="startReceiving()">Start Receiving</button>
            <button onclick="stopReceiving()">Stop Receiving</button>
        </div>
        <div class="message-log" id="messageLog">
            Messages from native code will appear here
        </div>
    </div>
    <script>
        const addon = require('./build/Release/addon');
        
        // Define buffer sizes for each direction
        const RENDERER_TO_NATIVE_SIZE = 12345;  // for renderer → native
        const NATIVE_TO_RENDERER_SIZE = 54321;  // for native → renderer
        
        // Create shared buffer with space for both directions plus control array (24 bytes)
        const sharedBuffer = new ArrayBuffer(24 + RENDERER_TO_NATIVE_SIZE + NATIVE_TO_RENDERER_SIZE);
        
        // Initialize the addon with the shared buffer and sizes
        addon.setSharedBuffer(sharedBuffer, RENDERER_TO_NATIVE_SIZE, NATIVE_TO_RENDERER_SIZE);

        // Control array layout (24 bytes total):
        // [0] - R→N signal
        // [1] - R→N length
        // [2] - N→R echo signal
        // [3] - N→R echo length
        // [4] - N→R message signal
        // [5] - N→R message length
        const control = new Int32Array(sharedBuffer, 0, 6);
        
        // Create views for the data regions
        const dataR2N = new Uint8Array(sharedBuffer, 24, RENDERER_TO_NATIVE_SIZE);
        const dataN2R = new Uint8Array(sharedBuffer, 24 + RENDERER_TO_NATIVE_SIZE, NATIVE_TO_RENDERER_SIZE);

        let testRunning = false;
        let testData = null;
        let messagesSent = 0;
        let isReceiving = false;

        function generateTestData(size) {
            if (size > RENDERER_TO_NATIVE_SIZE) {
                throw new Error('Test data size exceeds buffer size');
            }
            const data = new Uint8Array(size);
            for (let i = 0; i < size; i++) {
                data[i] = i % 256;
            }
            return data;
        }

        async function startTest() {
            const messageSize = parseInt(document.getElementById('messageSize').value);
            const duration = parseInt(document.getElementById('duration').value);
            
            if (messageSize > RENDERER_TO_NATIVE_SIZE) {
                alert('Message size cannot exceed renderer-to-native buffer size');
                return;
            }

            testData = generateTestData(messageSize);
            testRunning = true;
            messagesSent = 0;
            
            addon.startThroughputTest();
            
            // Start the test timer
            setTimeout(() => {
                stopTest();
            }, duration * 1000);
            
            // Start sending messages
            sendMessage();
            updateStats();
        }

        function stopTest() {
            testRunning = false;
            const finalStats = addon.getThroughputStats();
            document.getElementById('stats').innerHTML = `
                <strong>Final Results:</strong><br>
                Messages/sec: ${finalStats.messagesPerSecond.toFixed(2)}<br>
                MB/sec: ${(finalStats.bytesPerSecond / (1024 * 1024)).toFixed(2)}<br>
                Total Messages: ${finalStats.totalMessages}<br>
                Total MB: ${(finalStats.totalBytes / (1024 * 1024)).toFixed(2)}<br>
                Time: ${finalStats.seconds.toFixed(2)}s
            `;
        }

        function sendMessage() {
            if (!testRunning) return;
            
            // Try to send immediately if buffer is free
            if (Atomics.load(control, 0) === 0) {
                dataR2N.set(testData);
                control[1] = testData.length;
                Atomics.store(control, 0, 1);
                messagesSent++;
                
                // Wait for response
                checkResponse();
            } else {
                // Buffer is busy, try again very soon
                requestAnimationFrame(sendMessage);
            }
        }

        function checkResponse() {
            if (!testRunning) return;
            
            if (Atomics.load(control, 2) === 1) {
                Atomics.store(control, 2, 0);
                // Send next message immediately
                requestAnimationFrame(sendMessage);
            } else {
                // Check again very soon
                requestAnimationFrame(checkResponse);
            }
        }

        function startReceiving() {
            const interval = parseInt(document.getElementById('interval').value);
            addon.startSendingData(interval);
            isReceiving = true;
            startMessageCheck();
        }

        function stopReceiving() {
            addon.stopSendingData();
            isReceiving = false;
        }

        function startMessageCheck() {
            if (!isReceiving) return;

            if (Atomics.load(control, 4) === 1) {
                const length = control[5];
                if (length <= NATIVE_TO_RENDERER_SIZE) {
                    const decoder = new TextDecoder();
                    let data=dataN2R.slice(0, length);
                    const message = decoder.decode(data);
                    console.log(data, length);
                    const messageLog = document.getElementById('messageLog');
                    const messageElement = document.createElement('div');
                    messageElement.className = 'message';
                    messageElement.textContent = message;
                    messageLog.insertBefore(messageElement, messageLog.firstChild);
                    
                    while (messageLog.children.length > 100) {
                        messageLog.removeChild(messageLog.lastChild);
                    }
                }
                Atomics.store(control, 4, 0);
            }

            setTimeout(startMessageCheck, 1);
        }

        function updateStats() {
            if (!testRunning) return;
            
            const stats = addon.getThroughputStats();
            document.getElementById('stats').innerHTML = `
                <strong>Current Results:</strong><br>
                Messages/sec: ${stats.messagesPerSecond.toFixed(2)}<br>
                MB/sec: ${(stats.bytesPerSecond / (1024 * 1024)).toFixed(2)}<br>
                Total Messages: ${stats.totalMessages}<br>
                Total MB: ${(stats.totalBytes / (1024 * 1024)).toFixed(2)}<br>
                Time: ${stats.seconds.toFixed(2)}s
            `;
            
            if (testRunning) {
                setTimeout(updateStats, 100); // Update every 100ms
            }
        }

        // Cleanup when window closes
        window.addEventListener('beforeunload', () => {
            stopReceiving();
            addon.cleanup();
        });
    </script>
</body>
</html> 