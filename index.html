<!DOCTYPE html>
<html>
<head>
    <title>Shared Memory Communication Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 40px;
            background-color: #f0f0f0;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            border: none;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        input {
            padding: 8px;
            font-size: 16px;
            margin: 5px;
        }
        .controls {
            margin-bottom: 20px;
        }
        .message-log {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .message {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .send-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .send-controls input {
            flex: 1;
            min-width: 200px;
        }
        .queue-status {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="send-controls">
            <input type="text" id="messageInput" placeholder="Enter message to send">
            <button onclick="queueMessage()">Send</button>
        </div>
        <div class="queue-status" id="queueStatus">Queue: 0 messages</div>
        <div class="controls">
            <input type="number" id="interval" value="1000" min="100" max="10000"> ms interval
            <button onclick="startReceiving()">Start Receiving</button>
            <button onclick="stopReceiving()">Stop Receiving</button>
            <button onclick="triggerNativeCallback()">Trigger Native Callback</button>
        </div>
        <div class="message-log" id="messageLog">
            Messages from native code will appear here
        </div>
    </div>
    <script>
        const addon = require('./build/Release/addon');
        const Throttle = require('./throttle.js');
        let channel = null;

        class SharedMemoryChannel {
            constructor(rendererToNativeSize = 1024, nativeToRendererSize = 1024) {
                this.RENDERER_TO_NATIVE_SIZE = rendererToNativeSize;
                this.NATIVE_TO_RENDERER_SIZE = nativeToRendererSize;
                this.initialize();
            }

            initialize() {
                // Create shared buffer with space for both directions plus control array (16 bytes)
                this.sharedBuffer = new ArrayBuffer(16 + this.RENDERER_TO_NATIVE_SIZE + this.NATIVE_TO_RENDERER_SIZE);
                
                // Initialize the addon with the shared buffer and sizes
                addon.setSharedBuffer(this.sharedBuffer, this.RENDERER_TO_NATIVE_SIZE, this.NATIVE_TO_RENDERER_SIZE);

                // Set up the native callback
                addon.setMessageCallback((buffer) => {
                    
                    console.log('buffer', buffer);
                });

                // Control array layout (16 bytes total):
                // [0] - R→N signal
                // [1] - R→N length
                // [2] - N→R message signal
                // [3] - N→R message length
                this.control = new Int32Array(this.sharedBuffer, 0, 16/(32/8));
                
                // Create views for the data regions
                this.dataR2N = new Uint8Array(this.sharedBuffer, 16, this.RENDERER_TO_NATIVE_SIZE);
                this.dataN2R = new Uint8Array(this.sharedBuffer, 16 + this.RENDERER_TO_NATIVE_SIZE, this.NATIVE_TO_RENDERER_SIZE);

                this.messageQueue = [];
                this.isProcessingQueue = false;
                this.isReceiving = false;
                this.encoder = new TextEncoder();
                this.decoder = new TextDecoder();
                this.onMessageCallback = null;

                this.recv_fast_check_interval = 1;
                this.recv_slow_check_interval = 10;
                this.onMessageSentCallback = null;

                // Initialize throttle for queue updates
                this.queueUpdateThrottle = new Throttle(100); // Update UI at most every 100ms
            }

            send(message) {
                if (!this.sharedBuffer) return; // Guard against calls after cleanup
                const messageBytes = this.encoder.encode(message);
                
                if (messageBytes.length > this.RENDERER_TO_NATIVE_SIZE) {
                    throw new Error('Message too long');
                }

                this.messageQueue.push(messageBytes);

                if (!this.isProcessingQueue) {
                    this.isProcessingQueue = true;
                    requestAnimationFrame(() => this._processSendQueue());
                }
            }

            _processSendQueue() {
                if (!this.sharedBuffer || !this.isProcessingQueue) return; // Guard against calls after cleanup

                if (this.messageQueue.length === 0) {
                    this.isProcessingQueue = false;
                    return;
                }

                if (Atomics.load(this.control, 0) === 0) {
                    let packOffset = 0;
                    let pack_last_idx = -1;
                    
                    for (let i = 0; i < this.messageQueue.length; i++) {
                        if (packOffset + this.messageQueue[i].length > this.dataR2N.length) {
                            break;
                        }
                        this.dataR2N.set(this.messageQueue[i], packOffset);
                        packOffset += this.messageQueue[i].length;
                        pack_last_idx = i;
                    }

                    this.control[1] = packOffset;
                    Atomics.store(this.control, 0, 1);
                    this.messageQueue.splice(0, pack_last_idx + 1);
                    if (this.onMessageSentCallback) {
                        this.onMessageSentCallback();
                    }
                }

                if (this.isProcessingQueue) {
                    requestAnimationFrame(() => this._processSendQueue());
                }
            }

            startReceiving(callback) {
                if (!this.sharedBuffer) return; // Guard against calls after cleanup
                this.onMessageCallback = callback;
                this.isReceiving = true;
                this._processReceiveQueue();
            }

            stopReceiving() {
                this.isReceiving = false;
            }

            _processReceiveQueue() {
                if (!this.sharedBuffer || !this.isReceiving) return; // Guard against calls after cleanup
                // 1 means remote has new data, so we need to receive it
                if (Atomics.load(this.control, 2) === 1) {
                    const length = this.control[3];
                    if (length <= this.NATIVE_TO_RENDERER_SIZE) {
                        const data = this.dataN2R.slice(0, length);
                        const message = this.decoder.decode(data);
                        if (this.onMessageCallback) {
                            this.onMessageCallback(message, data);
                        }
                    }
                    //receive signal set to 0 means ready to receive another message
                    Atomics.store(this.control, 2, 0);
                    if (this.isReceiving) {
                        setTimeout(() => this._processReceiveQueue(), this.recv_fast_check_interval);
                    }
                } else if (this.isReceiving) {
                    setTimeout(() => this._processReceiveQueue(), this.recv_slow_check_interval);
                }
            }

            cleanup() {
                this.stopReceiving();
                this.isProcessingQueue = false;
                this.messageQueue = [];
                this.onMessageCallback = null;
                if (this.queueUpdateThrottle) {
                    this.queueUpdateThrottle.cancel();
                }
                addon.cleanup();
                
                // Clear buffer references
                this.sharedBuffer = null;
                this.control = null;
                this.dataR2N = null;
                this.dataN2R = null;
            }
        }

        // Initialize channel when page loads
        function initializeChannel() {
            if (channel) {
                channel.cleanup();
            }
            channel = new SharedMemoryChannel();
            channel.onMessageSentCallback = () => {
                // Use the throttle utility to update queue status
                channel.queueUpdateThrottle.schedule(() => {
                updateQueueStatus();
                });
            }
        }

        // Initialize on page load
        initializeChannel();
        
        function queueMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value;
            if (!message || !channel) return;
            
            for (let i = 0; i < 10; i++) {
                channel.send(message);
            }
            updateQueueStatus();
            // messageInput.value = '';
        }

        function startReceiving() {
            if (!channel) return;
            const interval = parseInt(document.getElementById('interval').value);
            addon.startSendingData(interval);
            channel.startReceiving((message, rawData) => {
                const messageLog = document.getElementById('messageLog');
                const messageElement = document.createElement('div');
                messageElement.className = 'message';
                messageElement.textContent = `Received: ${message}`;
                messageLog.appendChild(messageElement);
            });
        }

        function stopReceiving() {
            if (!channel) return;
            addon.stopSendingData();
            channel.stopReceiving();
        }

        function triggerNativeCallback() {
            addon.triggerTestCallback();
        }

        function updateQueueStatus() {
            if (!channel) return;
            document.getElementById('queueStatus').textContent = `Queue: ${channel.messageQueue.length} messages`;
        }

        // Add keyboard shortcut for sending messages
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                queueMessage();
            }
        });

        // Cleanup when window closes or refreshes
        window.addEventListener('beforeunload', () => {
            if (channel) {
                channel.cleanup();
                channel = null;
            }
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                if (channel) {
                    channel.cleanup();
                    channel = null;
                }
            } else {
                initializeChannel();
            }
        });
    </script>
</body>
</html> 